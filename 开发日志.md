# 通用日志组件

## 前期准备

### 前言

日志, 是用来记录程序运行过程中所产生的状态信息的一个组件, 日志有什么用呢? 说白了, 就是把中间状态记录下来, 这样等到程序出问题了, 就可以依据日志进行分析, 也就是说, 我们日后项目里面找Bug, 主体上靠的就是日志里面记录的信息.

那我们的日志组件, 想要为用户提供简便, 且能进行多种控制的日志输出.

1. 组件功能

   支持多级别日志消息. 这里的多级别有两层含义, 一是像我们之前写的, 那个很简陋的日志, 有调试级别的日志, 有提示级别的日志, 有警告级别的日志, 有致命级别的日志, 并且, 可以动态调控日志的输出级别, 比如, 在开发工程中, 我们可以让日志全部输出, 便于观察, 等到项目上线之后, 我们可以控制, 只输出错误, 致命级别的日志, 其它的干扰项都不输出.

   支持同步日志和异步日志, 为了防止各种各样的复杂服务环境, 导致日志工作出现阻塞和异常, 我们需要业务逻辑和日志逻辑相互独立, 尽可能不相互干扰, 日志的具体实现, 靠业务线程自己进行, 这样的就是同步日志, 日志的绝大多数逻辑, 都由另一个线程进行运行,业务逻辑可以继续往后运行, 不用管日志, 那就是异步日志.

   支持可靠写入日志到控制台, 也就是标准输出, 或者, 将日志放到某个文件里, 或者, 为了避免, 日志不断往一个文件里写, 导致文件大小过大, 不好分类, 查找, 分析, 所以我们可以让日志自主进行决策, 如果当前的文件已经很大了, 那么就换一个文件写, 又或者, 每隔一段时间, 就再换一个文件写, 这样的话, 因为它是以时间进行文件切换的, 所以查起来更方便, 删起来也好删. 具体采用什么逻辑, 由用户决定, 它只用一个可以, 用两个可以, 三个同时来也可以.

   支持日志落地的扩展, 日志落地, 就是日志往哪里输出的意思, 上面的是我们已经提供的现有功能, 输出到标准输出, 文件, 而且还可以自主切换文件, 除此之外, 我们还将提供一系列的扩展接口, 支持日志往其它地方落地, 比如数据库, 或者通过网络发到一个专门用来分析日志的服务器上.

   支持多线程环境下的并发写入. 当进行多线程开发逻辑时, 为了避免多个线程同时往文件里写信息, 我们需要确保线程安全, 不要混到一块写.

2. 开发环境

   - Ubuntu
   - code/vim
   - g++/gdb
   - CMake

3. 核心技术

   - 类的层次设计(继承多态的应用)
   - C++11(多线程, 智能指针, 右值引用, auto)
   - 双缓冲区(多线程的临界空间)
   - 生产消费者模型
   - 多线程
   - 设计模式(单例, 工厂, 代理, 建造者)

4. 项目依赖

   纯手搓, 不依赖任何第三方库

5. 日志的现实需求

   生产环境下的产品为了保证稳定性和安全性, 不允许开发人员使用调试器去排查问题, 此时, 我们就只能借助于日志系统的输出信息来帮助开发人员去定位, 解决问题
   Bug可能只有在特定的环境下才能命中, 日志就可以帮助开发人员去确定Bug的形成机理

   有一些高频操作, 必须要进行大量的测试才行, 如果用调试一个个来看的话, 实在太慢了, 所以可以直接看看日志.
   在并发环境下出现的问题, 用调试的方式很难定位, 此时我们就需要借助于日志进行分析.
   帮助新人宏观认识到项目运行的大致流程.

6. 日志系统实现的具体方式

   平时, 不打紧的时候, 我们可以用`printf, cout`等输出函数临时打印一下
   实际开发环境下, 为了方便排查问题, 一般会将日志输出到文件或者数据库里面, 主要分为同步日志和异步日志.

7. 同步日志

   同步日志是指, 必须在日志输出逻辑执行完毕之后, 才能执行后面的业务逻辑, 日志输出语句和服务的业务逻辑将在同一个线程中运行, 每次调用一次日志输出, 日志组件就要调一次系统API把日志输出到具体位置上.
   同步日志现在已经不会在生产环境下使用了, 因为一方面它的系统调用频次太高, 效率低下, 另一方面, 在日志输出过程中, 如果它输出不到指定位置, 比如磁盘性能不太好, 写不到文件里, 又或者, 网络不太行, 输出不到别的服务器或者数据库上, 那么就会阻塞住, 日志阻塞住不是特别要命的事, 要命的是, 它和业务逻辑在一个线程里面, 它阻塞了, 业务也阻塞了.

8. 异步日志

   在异步日志实现路径中, 业务线程会将日志数据放到一个特定的空间, 然后, 日志逻辑从另一个线程从该空间里取数据, 然后再去执行实际的输出逻辑, 这是一个典型的生产消费模型, 日志线程充当消费者, 业务线程充当生产者

### 相关知识补充

- 不定参数宏函数的使用

  现在我们有如下的一个打印程序

  ```c
  #include<stdio.h>
  
  int main()
  {
      printf("%s-%d\n", "可怜的小猪", 458);
      return 0;
  }
  ```

  ```shell
  [whisper@starry-sky example]$ ./ardsC 
  可怜的小猪-458
  ```

  现在, 我们有这样的需求, 那就是标注这行打印代码的来源文件和具体位置, 便于我们快速找到它们, 此时, 我们就可以通过加宏的方式来实现.

  ```c
  #include<stdio.h>
  
  int main()
  {
      printf("[%s:%d] %s-%d\n", __FILE__, __LINE__, "可怜的小猪", 458);
      return 0;
  }
  ```

  ```shell
  [whisper@starry-sky example]$ ./ardsC 
  [args.c:7] 可怜的小猪-458
  ```

  但此时就有一个问题, 一方面, 每次都带上`__FILE__, __LINE__`实在太烦人了, 但它们是宏, 又必须待在这里, 我又不能像绑定或者缺省参数对待它们, 所以, 我们只能再加一个宏, 把这个`printf`包装一下.

  ```c
  #include<stdio.h>
  
  // ... 表示宏的不定参数,    __VA_ARGS__是将不定参数展开
  #define LOG(fmt, ...) printf("[%s:%d] " fmt, __FILE__, __LINE__, __VA_ARGS__)
  
  int main()
  {
      LOG("%s-%d\n", "可怜的小猪", 458);
      return 0;
  }
  ```

  ```shell
  [whisper@starry-sky example]$ ./ardsC 
  [args.c:9] 可怜的小猪-458
  ```

  ![image-20250528143641603](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250528143641710.png)

  但此时就会引发一个小问题.

  ```c
  #include<stdio.h>
  
  #define LOG(fmt, ...) printf("[%s:%d] " fmt, __FILE__, __LINE__, __VA_ARGS__)
  
  int main()
  {
      LOG("可怜的小猪-458\n");
      return 0;
  }
  ```

  ```shell
  # 当我们没有给格式化字符串时, ...是空的, 导致__VA_ARGS__也是空的, 这使得其展开成printf("[%s:%d] " fmt, __FILE__, __LINE__, )的形式
  [whisper@starry-sky example]$ gcc args.c -o ardsC
  args.c: In function ‘main’:
  args.c:5:77: error: expected expression before ‘)’ token
      5 | #define LOG(fmt, ...) printf("[%s:%d] " fmt, __FILE__, __LINE__, __VA_ARGS__)
        |                                                                             ^
  args.c:9:5: note: in expansion of macro ‘LOG’
      9 |     LOG("可怜的小猪-458\n");
        |     ^~~
  ```

  此时, 我们可以在`__VA_ARGS__`前面加上`##`, 这里的`##`不应该被视为C语言的语法, 连接操作符, 而是GCC的编译扩展指令, VS应该会报错.

  ```shell
  [whisper@starry-sky example]$ cat args.c
  /*学习不定参宏函数的使用*/
  
  #include<stdio.h>
  
  #define LOG(fmt, ...) printf("[%s:%d] " fmt, __FILE__, __LINE__, ##__VA_ARGS__)
  
  int main()
  {
      LOG("可怜的小猪-458\n");
      return 0;
  }[whisper@starry-sky example]$ gcc args.c -o ardsC
  [whisper@starry-sky example]$ ./ardsC 
  [args.c:9] 可怜的小猪-458
  ```

- C语言不定参函数的使用方法

  我们在Linux章节已经做过相应的介绍, 在此我们简要复述一下.

  在C语言中, 可变参数函数的参数解析借助于参数列表类型`va_list`来实现, 

  ```c
  #include <stdarg.h>
  
  // 它们都是宏函数
  void va_start(va_list ap, last);
  type va_arg(va_list ap, type);
  void va_end(va_list ap);
  void va_copy(va_list dest, va_list src);
  ```

  `va_list`其实就是C语言中对于参数的迭代器类型, 使用`va_start`可以将其初始化, 每次调用`va_arg`都能按照指定类型取出数据, 并向后迭代一次.  `va_list`利用函数参数压栈时的地址连续性来对参数进行解析访问, 在第一个宏函数`va_start`中, 将会是最后一个压栈, 实际上就是第一个参数进行取地址, 进而依据该参数的地址对`va_list`实现初始化, 在这之后, 通过`va_arg`将指定大小的内存块解释成目标类型, 将其取出, 并向高地址处移动(栈由高地址向低地址生长, 所以向高地址移动就是寻找更前面的参数)对应的字节数, 以此达到迭代的目的.

  ```c
  #include<stdarg.h>
  
  // 仍是使用...表示不定参数
  void printNum(int count, ...)
  {
      va_list ap;
      va_start(ap, count);                             // 参数列表初始化
      for(int i = 0; i < count; ++i)
      {
          int num = va_arg(ap, int);
          printf("param[%d]:%d\n", i + 1, num);       // 自动返回相应类型和向后迭代
      }
      printf("\n");
      va_end(ap);                                     // va_end将列表无效化
  }
  
  int main()
  {
      printNum(4, 1, 2, 3, 4);
      printNum(2, 5, 6);
      return 0;
  }
  ```

  ```shell
  [whisper@starry-sky example]$ ./ardsC 
  param[1]:1
  param[2]:2
  param[3]:3
  param[4]:4
  
  param[1]:5
  param[2]:6
  ```

  不过上面的这种写法, 有些鸡肋, 原因是, 不定参数它不一定是整型, 而在上面的代码中, 我们将其都解释为了整型, 那要类型不一样怎么办, 此时, 我们就必须要借助于格式化字符串, 也就是`printf`的第一个参数, `fmt`, 对应上述代码的`"param[%d]:%d\n"`, 其中的`%d`就是告诉`printf`, 你要以这个地址为起始, 向后延伸整型的四个字节, 把这四字节的内存块解释成整型.但如果要我们亲自去写一个个识别占位符就太麻烦了, 所以我们可以借助于`vsnprintf`或者`vasprintf`.

  ```c
  #include <stdio.h>
  
  // vsnprintf是C标准中的函数, 定义于stdio.h中
  int vsnprintf(char str[restrict .size], size_t size,
                const char *restrict format, va_list ap);
  
  #define _GNU_SOURCE
  #include <stdio.h>
  
  // vasprintf是GNU的扩展函数接口, 不在标准C中, 需要添加_GNU_SOURCE启用扩展
  int vasprintf(char **restrict strp, const char *restrict fmt,
                va_list ap);
  ```

  它俩的功能其实都是一样的, 区别在于, `vsnprintf`是用户自己开辟一块存放字符串的数组充当缓冲区, 而`vasprintf`是自己在内部`malloc`出一个缓冲区, 然后使用二级指针把该空间的起始地址传给用户.

  我们推荐使用`vasprintf`, 这是因为, `vasprintf`会在内部预先计算一下解析出来的字符串长度, 然后再`malloc`, 把字符串往里面填充, 所以它自己开的空间绝对是够用的, 但`vsnprintf`的空间大小是由用户粗略把握的, 这样就会存在空间太大浪费, 或者较小不够放的风险, 当然, 对于`vasprintf`来说, 重要的一点是要记得释放空间.

  ```c
  #define _GNU_SOURCE
  #include<unistd.h>
  #include<stdio.h>
  #include<stdarg.h>
  #include<stdlib.h>
  
  void my_printf(const char* format, ...)
  {
      va_list ap;
      va_start(ap, format);
      char* buff = NULL;
      int res = vasprintf(&buff, format, ap);
  
      if(res > 0)
      {
          // 成功返回字符串长度
          write(0, buff, res);
          free(buff);
      }
  
     va_end(ap);
  }
  
  #define LOG(fmt, ...) my_printf("[%s:%d] " fmt, __FILE__, __LINE__, ##__VA_ARGS__)
  
  int main()
  {
      LOG("%s-%d\n", "祖玛游戏", 488);
      LOG("可怜的小猪-458\n");
      return 0;
  }
  ```

  ```shell
  [whisper@starry-sky example]$ ./ardsC 
  [args.c:55] 祖玛游戏-488
  [args.c:56] 可怜的小猪-458
  ```

  额, 程序名字怎么是这个, 是我之前打错了, 然后又用了历史指令.

- C++可变参数函数

  C++可变参数函数的使用, 在语言章节中我们曾经说过, 在这里我们再次复述一遍.

  ```cpp
  #include <iostream>
  
  using namespace std;
  
  template <typename T, typename... Args>
  void xprintf(const T& val, Args&&... args)
  {
      cout << sizeof...(args) << endl;
  }
  
  int main()
  {
      xprintf(1, 2.3, 5, 7.04, "abcdef");
      xprintf(6, 5, 3.14);
      return 0;
  }
  ```

  `typename`比`class`更加安全, 我们在语言章节的`list`讲过这个, `... Args`就是不定参数类型的展开, 在这里, 我们又用`Args&&... args`实现了完美引用, 这都不重要, 重要的是, 我们可以通过`sizeof...(args)`得到参数包中的数据个数.

  ```shell
  [whisper@starry-sky example]$ g++ args.cpp -o argsCPP
  [whisper@starry-sky example]$ ./argsCPP 
  4
  2
  ```

  不过之后的参数展开, 和这个`sizeof...`没有显著关系, 我们是通过递归调用的方式来解析参数包的, 我们不断地自递归, 将参数一个个拆出来, 最后通过无参重载函数的方式作为递归出口终止递归.

  ```cpp
  #include <iostream>
  
  using namespace std;
  
  void xprintf()
  {
      cout << endl;
  }
  
  template <typename T, typename... Args>
  void xprintf(const T& val, Args&&... args)
  {
      cout << val << " ";
      xprintf(std::forward<Args>(args)...);
  }
  
  int main()
  {
      xprintf(1, 2.3, 5, 7.04, "abcdef");
      xprintf(6, 5, 3.14);
      return 0;
  }
  ```

  我们使用`std::forward<Args>(args)...`的形式, 将参数包里的参数以完美转发的形式展开, 如果还有参数, 那么调用的就是`xprintf`的模版函数, 这样, 就可以把参数包中的参数一个个解析出来, 最后, 当没有参数的时候, 便会进入无参的`xprintf`, 让递归回溯, 终止的说法不太准确.

  ```shell
  [whisper@starry-sky example]$ ./argsCPP 
  1 2.3 5 7.04 abcdef 
  6 5 3.14 
  ```

  

  
