# 通用日志组件

## 前期准备

### 前言

日志, 是用来记录程序运行过程中所产生的状态信息的一个组件, 日志有什么用呢? 说白了, 就是把中间状态记录下来, 这样等到程序出问题了, 就可以依据日志进行分析, 也就是说, 我们日后项目里面找Bug, 主体上靠的就是日志里面记录的信息.

那我们的日志组件, 想要为用户提供简便, 且能进行多种控制的日志输出.

1. 组件功能

   支持多级别日志消息. 这里的多级别有两层含义, 一是像我们之前写的, 那个很简陋的日志, 有调试级别的日志, 有提示级别的日志, 有警告级别的日志, 有致命级别的日志, 并且, 可以动态调控日志的输出级别, 比如, 在开发工程中, 我们可以让日志全部输出, 便于观察, 等到项目上线之后, 我们可以控制, 只输出错误, 致命级别的日志, 其它的干扰项都不输出.

   支持同步日志和异步日志, 为了防止各种各样的复杂服务环境, 导致日志工作出现阻塞和异常, 我们需要业务逻辑和日志逻辑相互独立, 尽可能不相互干扰, 日志的具体实现, 靠业务线程自己进行, 这样的就是同步日志, 日志的绝大多数逻辑, 都由另一个线程进行运行,业务逻辑可以继续往后运行, 不用管日志, 那就是异步日志.

   支持可靠写入日志到控制台, 也就是标准输出, 或者, 将日志放到某个文件里, 或者, 为了避免, 日志不断往一个文件里写, 导致文件大小过大, 不好分类, 查找, 分析, 所以我们可以让日志自主进行决策, 如果当前的文件已经很大了, 那么就换一个文件写, 又或者, 每隔一段时间, 就再换一个文件写, 这样的话, 因为它是以时间进行文件切换的, 所以查起来更方便, 删起来也好删. 具体采用什么逻辑, 由用户决定, 它只用一个可以, 用两个可以, 三个同时来也可以.

   支持日志落地的扩展, 日志落地, 就是日志往哪里输出的意思, 上面的是我们已经提供的现有功能, 输出到标准输出, 文件, 而且还可以自主切换文件, 除此之外, 我们还将提供一系列的扩展接口, 支持日志往其它地方落地, 比如数据库, 或者通过网络发到一个专门用来分析日志的服务器上.

   支持多线程环境下的并发写入. 当进行多线程开发逻辑时, 为了避免多个线程同时往文件里写信息, 我们需要确保线程安全, 不要混到一块写.

2. 开发环境

   - Ubuntu
   - code/vim
   - g++/gdb
   - CMake

3. 核心技术

   - 类的层次设计(继承多态的应用)
   - C++11(多线程, 智能指针, 右值引用, auto)
   - 双缓冲区(多线程的临界空间)
   - 生产消费者模型
   - 多线程
   - 设计模式(单例, 工厂, 代理, 建造者)

4. 项目依赖

   纯手搓, 不依赖任何第三方库

5. 日志的现实需求

   生产环境下的产品为了保证稳定性和安全性, 不允许开发人员使用调试器去排查问题, 此时, 我们就只能借助于日志系统的输出信息来帮助开发人员去定位, 解决问题
   Bug可能只有在特定的环境下才能命中, 日志就可以帮助开发人员去确定Bug的形成机理

   有一些高频操作, 必须要进行大量的测试才行, 如果用调试一个个来看的话, 实在太慢了, 所以可以直接看看日志.
   在并发环境下出现的问题, 用调试的方式很难定位, 此时我们就需要借助于日志进行分析.
   帮助新人宏观认识到项目运行的大致流程.

6. 日志系统实现的具体方式

   平时, 不打紧的时候, 我们可以用`printf, cout`等输出函数临时打印一下
   实际开发环境下, 为了方便排查问题, 一般会将日志输出到文件或者数据库里面, 主要分为同步日志和异步日志.

7. 同步日志

   同步日志是指, 必须在日志输出逻辑执行完毕之后, 才能执行后面的业务逻辑, 日志输出语句和服务的业务逻辑将在同一个线程中运行, 每次调用一次日志输出, 日志组件就要调一次系统API把日志输出到具体位置上.
   同步日志现在已经不会在生产环境下使用了, 因为一方面它的系统调用频次太高, 效率低下, 另一方面, 在日志输出过程中, 如果它输出不到指定位置, 比如磁盘性能不太好, 写不到文件里, 又或者, 网络不太行, 输出不到别的服务器或者数据库上, 那么就会阻塞住, 日志阻塞住不是特别要命的事, 要命的是, 它和业务逻辑在一个线程里面, 它阻塞了, 业务也阻塞了.

8. 异步日志

   在异步日志实现路径中, 业务线程会将日志数据放到一个特定的空间, 然后, 日志逻辑从另一个线程从该空间里取数据, 然后再去执行实际的输出逻辑, 这是一个典型的生产消费模型, 日志线程充当消费者, 业务线程充当生产者

### 相关知识补充

